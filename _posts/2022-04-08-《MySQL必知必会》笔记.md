---
layout: article-toc
title: 《MySQL必知必会》笔记
tags: 
    - 笔记
    - MySQL
    - 数据库
---
《MySQL必知必会》学习笔记
<!--more-->
# MySQL必知必会
## 安装

1. 安装：
```shell
# 安装mysql
apt install mysql-server
# 启动mysql
sudo mysql -u root -p
# 重启mysql
sudo service mysql restart
```

2. 连接：
```shell
# 更改配置
sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf
# 将找到 bind-address = 127.0.0.1 并注释掉 → # bind-address = 127.0.0.1
```

3. 将Host设置为通配符%
  
Host列指定了允许用户登录所使用的IP，比如user=root Host=192.168.1.1。这里的意思就是说root用户只能通过192.168.1.1的客户端去访问。 user=root Host=localhost，表示只能通过本机客户端去访问。而%是个通配符，如果Host=192.168.1.%，那么就表示只要是IP地址前缀为“192.168.1.”的客户端都可以连接。如果Host=%，表示所有IP都有连接权限。
```sql
update user set host = '%' where user ='root';
```

1. 更改root用户密码
```sql
ALTER user 'root'@'%' IDENTIFIED BY 'newpassward';
flush privileges;
```

5. 若连接报错
```sql
# 进入mysql，任选一个数据库，如：
use mysql;
select user, plugin from user; 
# 若plugin root的字段是auth_socket，将其改为mysql_native_password
update user set plugin='mysql_native_password' where user='root';
```



## 1. 数据库基础
**数据库（database）** 保存有组织的数据的容器（一个文件或一组文件）。  

**数据库管理系统（DBMS）** 通过DBMS创建和操纵数据库。  
- 基于共享文件系统，通常用于桌面用途
- 基于客户机-服务器的DBMS

**表（table）** 某种特定类型数据的结构化清单，是一种结构化文件，用来存储某种特定类型的数据。  

**模式（schema）** 关于数据库和表的布局及特性的信息。  

**列（column）** 表中的一个字段。所有表都是由一个或多个列组成的。  

**数据类型（datatype）** 所容许的数据的类型。每个表列有相应的数据类型。  

**行（row）** 表中的一个记录（record）。  

**主键（primary key）** 唯一标识表中每行的一（组）列。（可以理解为ID列）  
- 主键值规则：
  - 任意两行都不具有相同的主键值。
  - 每个行都必须具有一个主键值。（主键列不允许NULL值）  

**SQL（Structured Query Language）** 一种专门用来与数据库通信的语言。  

## 2. MySQL简介
**MySQL**是一种DBMS，是一种基于客户机-服务器的数据库软件
- 特点：成本低、性能好、可信赖、简单

结束命令：命令用;或\g结束  
退出命令行：输入quit或exit  

## 3. 使用MySQL
**选择数据库** 使用关键字"USE"
```sql
#输入
USE crashcourse;
#输出
Database changed
```

**列出信息** 使用关键字"SHOW"
```sql
#显示已有的数据库
SHOW DATABASES;
#获得一个数据库内的表的列表
SHOW TABLES;
#显示表列
SHOW COLUMNS FROM xxx; #xxx为表名
#用DESCRIBE作为SHOW COLUMNS FROM的快捷方式
DESCRIBE xxx;

#其他的SHOW语句
SHOW STATUS; #显示广泛的服务器状态信息
SHOW CREATE DATABASE; #显示创建特定数据库
SHOW CREATE TABLE; #显示创建特定表
SHOW GRANTS; #显示授予用户的安全权限
SHOW ERRORS; #显示服务器错误
SHOW WARNINGS; #显示警告信息
``` 

## 4. 检索数据

**SELECT关键词** 检索表数据
```sql
#从products表中检索一个名为prod_name的列
SELECT prod_name FROM products; 
```

mysql不区分大小写。
- 建议：对关键词使用大写，对列和表名使用小写，易于阅读和调试。

**从一个表中检索多个列** 用逗号将列名分隔，最后一个列名后不加。

**检索所有列** 在列名位置使用*通配符
```sql
SELECT * 
FROM products;
```

**检索内容不同的行** 使用关键字DISTINCT，放在列名的前面
```sql
SELECT DISTINCT vend_id
FROM products;
```

**限制结果** 使用LIMIT子句
```sql
#返回结果前5行的数据
SELECT prod_name
FROM products
LIMIT 5;

#返回从第5行开始的5行
SELECT prod_name
FROM products
LIMIT 5,5;

#代替语法
LIMIT 4 OFFSET 3;
#等价于
LIMIT 3,4;
```

## 5. 排序检索数据
**排序数据** 使用ORDER BY子句。取一个或多个列的名字，据此对输出进行排序。
```sql
#将prod_name列以字母顺序排序
SELECT prod_name
FROM product
ORDER BY prod_name;
```

```sql
#检索三个列，按其中两列对结果排序
SELECT prod_id,prod_price,prod_name
FROM products
ORDER BY prod_price,prod_name;
#先按prod_price从小到大排序，如果price值相同再按name排序
```

**降序排列** 使用DESC关键字。(升序使用ASC关键字，但意义不大)
```sql
#按价格以降序排列产品
SELECT prod_id,prod_price,prod_name
FROM products
ORDER BY prod_price DESC;

#先按价格降序排序，再对名字进行排序
SELECT prod_id,prod_price,prod_name
FROM products
ORDER BY prod_price DESC,prod_name;
#如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。
```

**查询最值** 使用ORDER BY和LIMIT组合。
```sql
#找出最贵的物品
SELECT prod_price
FROM products
ORDER BY prod_price DESC
LIMIT 1;
#ORDER BY子句位于FROM子句之后，LIMIT子句在ORDER BY子句之后
```

## 6. 过滤数据

**搜索条件/过滤条件** 使用WHERE子句(筛选)。
```sql
SELECT prod_name, prod_price
FROM products
WHERE prod_price = 2.50;
```

**WHERE子句操作符** 

| 操作符  | 说明               |
| ------- | ------------------ |
| =       | 等于               |
| <>      | 不等于             |
| !=      | 不等于             |
| <       | 小于               |
| <=      | 小于等于           |
| >       | 大于               |
| >=      | 大于等于           |
| BETWEEN | 在指定的两个值之间 |

**范围值检查** 使用BETWEEN操作符，低端值与高端值用AND关键字分隔  
```sql
SELECT prod_name, prod_price
FROM products
WHERE prod_price BETWEEN 5 AND 10;
```

**空值** NULL代表没有值，使用WHERE IS NULL子句进行检查
```sql
SELECT cust_id
FROM customers
WHERE cust_email IS NULL;
```


## 7. 数据过滤

**操作符**(operator) 用来联结或改变WHERE子句中的子句的关键字。也称*逻辑操作符*(logical operator)

**AND操作符** 用于WHERE子句，用来指示检索满足所有给点给条件的行。
```sql
SELECT  prod_id,prod_price,prod_name
FROM products
WHERE vend_id = 1003 AND prod_price <= 10;
```

**OR操作符** 用于WHERE子句，用来表示检索匹配任意给定条件的行。
```sql
SELECT prod_name,prod_price
FROM products
WHERE vend_id = 1002 OR vend_id = 1003;
```

**计算次序** SQL会优先处理AND操作符，再处理OR操作符。可使用圆括号改变计算次序。
```sql
#目标：列出价格大于等于10美元且由1002或1003制造的产品

#错误语句
SELECT prod_name,prod_price
FROM products
WHERE vend_id = 1002 OR vend_id = 1003 AND prod_price >= 10;

#正确语句
SELECT prod_name,prod_price
FROM products
WHERE (vend_id = 1002 OR vend_id = 1003) AND prod_price >= 10;
```

**IN操作符** 在WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当。
```sql
SELECT prod_name,prod_price
FROM products
WHERE vend_id IN(1002,1003)
#相当于 WHERE vend_id = 1002 OR vend_id = 1003
ORDER BY prod_name;
```

**NOT操作符** WHERE子句中用来否定后跟条件的关机字。(MySQL中支持使用NOT对IN、BETWEEN和EXISTS子句取反)
```sql
SELECT prod_name,prod_price
FROM products
WHERE vend_id NOT IN(1002,1003)
ORDER BY prod_name;
```


## 8. 用通配符进行过滤

**搜索模式** (search pattern) 由字面值、通配符或两者组合构成的搜素条件。

**通配符** (wildcard) 用来匹配值的一部分的特殊字符。实际是SQL的WHERE子句中有特殊含义的字符。

**LIKE操作符** LIKE从技术上讲是*谓词*(predicate)，指示MySQL后面跟的搜索模式利用通配符匹配而不是直接相等匹配进行比较。

**百分号%通配符** 在搜索串中，%表示任何字符出现任意次数，也可以匹配0个字符，但不能匹配NULL。
```sql
#找出素有以词jet起头的产品
SELECT prod_id,prod_name
FROM products
WHERE prod_name LIKE 'jet%';

#搜索任何位置包含文本anvil的产品
SELECT prod_id,prod_name
FROM products
WHERE prod_name LIKE '%anvil%';

#搜索以s起头以e结尾的所有产品
SELECT prod_id,prod_name
FROM products
WHERE prod_name LIKE 's%e';
```

**下划线_通配符** 用途与%一样，但_只能匹配*单个字符*而不是多个字符，不能多也不能少。
```sql
#输入
SELECT prod_id,prod_name
FROM products
WHERE prod_name LIKE '_ ton anvil';
```
输出
```
+---------+-------------+
| prod_id | prod_name   |
+---------+-------------+
| ANV02   | 1 ton anvil |
| ANV03   | 2 ton anvil |
+---------+-------------+
```
```sql
#输入
SELECT prod_id,prod_name
FROM products
WHERE prod_name LIKE '% ton anvil';
```
输出
```
+---------+--------------+
| prod_id | prod_name    |
+---------+--------------+
| ANV01   | .5 ton anvil | #".5"占用两个字符
| ANV02   | 1 ton anvil  |
| ANV03   | 2 ton anvil  |
+---------+--------------+
```

**使用通配符**
- 代价
  - 延长搜索时间
- 技巧
  - 不要过度使用通配符。
  - 除非必要不要把通配符用在搜索模式的开始处。
  - 不要放醋通配符的位置。

## 正则表达式

**限定符**
- "**?**"，代表它前面的字符需要出现0次或1次。
  - "used?"可以匹配到"use"和"used"
- "**\***"，代表它前面的字符可以出现0次、1次或者多次。
  - "ab*c"可以匹配到"ac"、"abc"和"abbbbbbbc"
- "**+**"，代表它前面的字符可以出现1次或者多次。
  - "ab+c"可以匹配到"abc"和"abbbbbbbc
- "**{...}**"，限定前面的字符出现次数的范围。
  - {6}，限定前面字符出现6次；
  - {2,6}，限定前面字符出现2~6次；
  - {2,}，限定前面字符出现大于等于2次。
- 若想限定前面的多个字符，则需用(...)将前面的多个字符括起来。

![](/assets/images/regex.png)


## 9. 用正则表达式进行搜索

**正则表达式的作用** 匹配文本，将一个模式(正则表达式)与一个文本串进行比较。

```sql
#检索prod_name包括文本1000的所有行
SELECT prod_name
FROM products
WHERE prod_name REGEXP '1000'
ORDER BY prod_name;

#检索包括文本x000的行
SELECT prod_name
FROM products
WHERE prod_name REGEXP '.000' #"."可以匹配任意一个字符
ORDER BY prod_name;
```

**区分大小写** 使用*BINARY关键字*可以区分大小写。
```sql
WHERE prod_name REGEXP BINARY 'JetPack .1000'
```

**OR匹配** 使用“|”，为正则表达式的OR操作符，表示匹配其中之一。
```sql
SELECT prod_name
FROM products
WHERE prod_name REGEXP '1000|2000|3000'
ORDER BY prod_name;
```

**匹配几个字符之一** 指定一组用[...]括起来的字符
```sql
SELECT prod_name
FROM products
WHERE prod_name REGEXP '[123] Ton'
#[123] Ton为[1|2|3] Ton的缩写，可以匹配1 Ton、2 Ton和3Ton
ORDER BY prod_name;
```

**否定** 使用"\^"字符，如[^123]匹配除1、2或3以外的任何东西。

**匹配范围** 可以用"-"来定义一个范围，如用[0-9]代替[0123456789]，其余例子：[1-3]、[6-9]、[a-z]

**转义** 使用"\\"来进行转义(MySQL需要一个反斜杠解释，正则表达式需要一个反斜杠解释)，如："\\\\-"、"\\\\."、"\\\\\\"。
```sql
#输入
SELECT vend_name
FROM vendors
WHERE vend_name REGEXP '\\.'
ORDER BY vend_name;
```
输出
```
+--------------+
| vend_name    |
+--------------+
| Furball Inc. |
+--------------+
```
"\\\\"也用来引用元字符

| 元字符 |   说明   |
| :----: | :------: |
| \\\\f  |   换页   |
| \\\\n  |   换行   |
| \\\\r  |   回车   |
| \\\\t  |   制表   |
| \\\\v  | 纵向制表 |


**字符类**

| 类         | 说明                                                   |
| ---------- | ------------------------------------------------------ |
| [:alnum:]  | 任意字母和数字（同[a-zA-Z0-9]）                        |
| [:alpha:]  | 任意宇符（同[a-ZA-Z]）                                 |
| [:blank:]  | 空格和制表（同[\\\t]）                                 |
| [:cntrl:]  | ASCI控制字符 (ASCII 0到31和127）                       |
| [:digit:]  | 任意数字（同[0-9]）                                    |
| [:graph:]  | 与[:print]相同，但不包括空格                           |
| [:lower:]  | 任意小写字母（同[a-z]）                                |
| [:print:]  | 任意可打印字符                                         |
| [:punct:]  | 既不在[alnum]又不在[:cntr1:]中的任意字符               |
| [:space:]  | 包括空格在内的任意空白字符（同[\\\f\\\n\\\r\\\t\\\v]） |
| [:upper:]  | 任意大写字母（同[A-Z]）                                |
| [:xdigit:] | 任意十六进制数字（同[a-fA-F0-9）                       |

**匹配多个实例**

| 元字符 | 说明                          |
| ------ | ----------------------------- |
| *      | 0个或多个匹配                 |
| +      | 1个或多个匹配（等于{1,}）     |
| ?      | 0个或1个匹配（等于{0,1}）     |
| {n}    | 指定数目的匹配                |
| {n,}   | 不少于指定数目的匹配          |
| {n,m}  | 匹配数目的范围 （m不超过255） |

**定位符** 用来匹配特定位置的文本

| 元字符   | 说明       |
| -------- | ---------- |
| ^        | 文本的开始 |
| $        | 文本的结尾 |
| \[[:<:]] | 词的开始   |
| \[[:>:]] | 词的结尾   |

**^的双重用途**
1. 在集合中[^...]，用来否定该合集
2. 用来指串的开始处


## 10. 创建计算字段
目的：直接从数据库中检索出转换、计算或格式化过的数据。  
计算字段是运行时在SELECT语句内创建的，并不实际存在于数据库表中。

**字段** 与*列*(column)类似，"列"一般指数据库中本身的列，"字段"指运行时创建的实际不存在的列。

**拼接字段** 使用Concat()函数来拼接串，将多个值联结到一起构成单个值。

```sql
#按"vend_name(vend_country)"的格式输出
#输入
SELECT Concat(vend_name,' (',vend_country,')')  #将四个串联结起来，分别用逗号隔开
FROM vendors
ORDER BY vend_name;
#输出
+-----------------------------------------+
| Concat(vend_name,' (',vend_country,')') |
+-----------------------------------------+
| ACME (USA)                              |
| Anvils R Us (USA)                       |
| Furball Inc. (USA)                      |
| Jet Set (England)                       |
| Jouets Et Ours (France)                 |
| LT Supplies (USA)                       |
+-----------------------------------------+
```

**Trim函数** 删除多余的空格
- Trim( )去掉串左右两边的空格
- LTrim( )去掉串左边的空格
- RTrim( )去掉串右边的空格
```sql
#输入
SELECT Concat('A',Trim(' 123 '),'B');
SELECT Concat('A',LTrim(' 123 '),'B');
SELECT Concat('A',RTrim(' 123 '),'B');
#输出
A123B
A123 B
A 123B
```

**别名** 使用*AS关键字*对字段或值赋予别名(替换名)，也称导出列(derived column)。
```sql
#输入
SELECT Concat(vend_name,' (',RTrim(vend_country),')') AS vend_title
FROM vendors
ORDER BY vend_name;
#输出
+-------------------------+
| vend_title              |
+-------------------------+
| ACME (USA)              |
| Anvils R Us (USA)       |
| Furball Inc. (USA)      |
| Jet Set (England)       |
| Jouets Et Ours (France) |
| LT Supplies (USA)       |
+-------------------------+
```

**算术计算** 使用算数操作符 ("+"、"-"、"*"、"/")对列执行算术计算
```sql
#汇总物品的价格
SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price
FROM orderitems
WHERE order_num = 20005;
#输出
+---------+----------+------------+----------------+
| prod_id | quantity | item_price | expanded_price |
+---------+----------+------------+----------------+
| ANV01   |       10 |       5.99 |          59.90 |
| ANV02   |        3 |       9.99 |          29.97 |
| TNT2    |        5 |      10.00 |          50.00 |
| FB      |        1 |      10.00 |          10.00 |
+---------+----------+------------+----------------+
```


## 11. 数据处理函数
*相对于SQL语句，函数的可移植性不强，不同DBMS都有各自独有的函数。在使用函数时，应做好代码注释。*

**文本处理函数**

| 函数        | 说明              |
| ----------- | ----------------- |
| Left()      | 返回串左边的字符  |
| Right()     | 返回串右边的字符  |
| Length()    | 返回串的长度      |
| Locate()    | 找出串的一个字串  |
| LTrim()     | 去掉串左边的空格  |
| RTrim()     | 去掉串右边的空格  |
| Upper()     | 将串转换为大写    |
| Lower()     | 将串转换为小写    |
| Soundex()   | 返回串的SOUNDEX值 |
| SubString() | 返回子串的字符    |

```sql
#输入
SELECT vend_name, Upper(vend_name) AS vend_name_upcase
FROM vendors
ORDER BY vend_name;
#输出
+----------------+------------------+
| vend_name      | vend_name_upcase |
+----------------+------------------+
| ACME           | ACME             |
| Anvils R Us    | ANVILS R US      |
| Furball Inc.   | FURBALL INC.     |
| Jet Set        | JET SET          |
| Jouets Et Ours | JOUETS ET OURS   |
| LT Supplies    | LT SUPPLIES      |
+----------------+------------------+
```

**SOUNDEX** 将文本串转换为描述其语音表示的字母数字模式的算法，使得能对串进行发音比较而不是字母比较。
```sql
#匹配发音类似Y.Lie的联系名
#输入
SELECT cust_name, cust_contact
FROM customers
WHERE Soundex(cust_contact) = Soundex('Y.Lie');
#输出
+-------------+--------------+
| cust_name   | cust_contact |
+-------------+--------------+
| Coyote Inc. | Y Lee        |
+-------------+--------------+
```

**日期和时间处理函数**
日期格式：yyyy-mm-dd

| 函数          | 说明                           |
| ------------- | ------------------------------ |
| AddDate()     | 增加一个日期（天、周等）       |
| AddTime()     | 增加一个时间 （时、分等）      |
| CurDate()     | 返回当前日期                   |
| CurTime()     | 返回当前时间                   |
| Date()        | 返回目期时间的目期部分         |
| DateDiff()    | 计算两个日期之差               |
| Date Add()    | 高度灵活的日期运算函数         |
| Date Format() | 返回一个格式化的日期或时间串   |
| Day()         | 返回一个日期的天数部分         |
| DayOfWeek()   | 对于一个日期，返回对应的星期几 |
| Hour()        | 返回一个时间的小时部分         |
| Minute()      | 返回一个时间的分钟部分         |
| Month()       | 返回一个日期的月份部分         |
| Now()         | 返回当前日期和时间             |
| Second()      | 返回一个时间的秒部分           |
| Time()        | 返回一个日期时间的时间部分     |
| Year()        | 返回一个日期的年份部分         |


若目标order_date（数据类型为datetime）为2005-09-01 11:30:05
```sql
WHERE order_date = '2005-09-01'   #匹配失败
WHERE Date(order_date) = '2005-09-01'   #匹配成功
```
```sql
where year(order_date) = 2005 AND Month(order_date) = 9
#检索出order_date为2005年9月的所有行
```

**数值处理函数**

| 函数   | 函数               |
| ------ | ------------------ |
| Abs () | 返回一个数的绝对值 |
| Cos()  | 返回一个角度的余弦 |
| Exp()  | 返回一个数的指数值 |
| Mod()  | 返回除操作的余数   |
| Pi()   | 返回圆周率         |
| Rand() | 返回一个随机数     |
| Sin()  | 返回一个角度的正弦 |
| Sart() | 返回一个数的平方根 |
| Tan()  | 返回一个角度的正切 |



## 12. 汇总数据

**聚集函数** 运行在行组上，计算和返回单个值的函数。主要有以下几种：
- 确定表中（满足某条件）的行数
- 获得表中行组的和
- 找出表列的最大值、最小值和平均值

**AVG( )函数** 通过对表中行数计数并计算特定列值之和，求得该*列的平均值*。
- 只用于单个列，要获得多个列的平均值应使用多个AVG( )函数。
- 函数忽略列值为NULL的行。

```sql
#返回vend_idwei_1003的产品的平均价格
SELECT AVG(prod_price) AS avg_price
FROM products
WHERE vend_id = 1003;
#输出
+-----------+
| avg_price |
+-----------+
| 13.212857 |
+-----------+
```

**COUNT( )函数** 计数，可用来确定*表中行的数目*或符合特定条件的行的数目。
- COUNT(*)，计算行数，包括空值(NULL)和非空值
```sql
SELECT COUNT(*) AS num_cust
FROM customers;
#输出
+----------+
| num_cust |
+----------+
|        5 |
+----------+
```
- COUNT("column")，对特定列中具有值的行进行计数，忽略NULL值
```sql
SELECT COUNT(cust_email) AS num_cust
FROM customers;
#输出
+----------+
| num_cust |
+----------+
|        3 |    #cust_email有两个NULL
+----------+
```

**MAX( )函数** 要求指定列名，返回指定列中的最大值。
```sql
#找出最贵物品的价格
SELECT MAX(prod_price) AS max_price
FROM products;

#找出最贵物品的名字和价格
SELECT prod_name, prod_price AS max_price
FROM products
WHERE prod_price = (SELECT MAX(prod_price) FROM products);
```

**MIN( )函数** 要求指定列名，返回指定列中的最小值。与MAX()功能相反。

**SUM( )函数** 返回指定列值的和。
```sql
#返回订单号为20005的总订单金额
SELECT SUM(item_price*quantity) AS total_price
FROM orderitems
WHERE order_num = 20005;
```

**聚集不同值**
聚集函数的参数
- ALL参数，可以不给出（ALL为默认行为）
- DISTINCT参数，只包含不同的值。必须用于指定的列名前。
```sql
#返回不同价格的产品的平均价格
SELECT AVG(DISTINCT prod_price) AS avg_price
FROM products
WHERE vend_id = 1003;
```

**组合聚集函数**
```sql
SELECT COUNT(*) AS num_items,
       MIN(prod_price) AS price_min,
       MAX(prod_price) AS price_max,
       AVG(prod_price) AS price_avg
FROM products;
#输出
+-----------+-----------+-----------+-----------+
| num_items | price_min | price_max | price_avg |
+-----------+-----------+-----------+-----------+
|        14 |      2.50 |     55.00 | 16.133571 |
+-----------+-----------+-----------+-----------+
```

## 13. 分组数据
把数据分为多个逻辑组。以对每个组进行聚集计算

**创建分组** 使用GROUP BY子句
- GROUP BY子句可以包含任意数目的列，可以对分组进行嵌套
- 若进行了嵌套，数据在最后规定的分组上进行汇总
- 每个列都必须是检索列或有效的表达式(不能是聚集函数)
- SELECT语句中的每个列(除了聚集计算)都必须在GROUP BY子句中给出
- 若分组列中有NULL值，NULL将作为一个分组返回，若有多行NULL，将被分为一组
- GROUP BY在WHERE后，在ORDER BY之前

**WITH ROLLUP关键字** 用来在分组统计数据的基础上再进行统计汇总

```sql
#按vend_id分组并计数
SELECT vend_id, COUNT(*) AS num_prods
FROM products
GROUP BY vend_id WITH ROLLUP;
#输出
+---------+-----------+
| vend_id | num_prods |
+---------+-----------+
|    1001 |         3 |
|    1002 |         2 |
|    1003 |         7 |
|    1005 |         2 |
|    NULL |        14 |   #WITH ROLLUP的结果
+---------+-----------+
```

**过滤分组** 使用HAVING子句过滤分组。(WHERE子句过滤行)
```sql
#过滤出数量为两个以上的订单
SELECT cust_id,COUNT(*) AS orders
FROM orders
GROUP BY cust_id
HAVING COUNT(*) >= 2;
#输出
+---------+--------+
| cust_id | orders |
+---------+--------+
|   10001 |      2 |
+---------+--------+
```

**SELECT子句的顺序** 从上至下

| 子句     | 说明               | 是否必须使用           |
| -------- | ------------------ | ---------------------- |
| SELECT   | 要返回的列或表达式 | 是                     |
| FROM     | 从中检索数据的表   | 仅在从表选择数据时使用 |
| WHERE    | 行级过滤           | 否                     |
| GROUP BY | 分组说明           | 仅在按组计算聚集时使用 |
| HAVING   | 组级过滤           | 否                     |
| ORDER BY | 输出排序顺序       | 否                     |
| LIMIT    | 要检索的行数       | 否                     |


## 14. 使用子查询
**查询** 任何SQL语句都是查询，但一般*查询*指SELECT语句

**子查询** 嵌套在其他查询中的查询.（实际使用时由于性能的限制，不能嵌套太多的子查询）

```sql
#列出订购物品TNT2的所有客户
SELECT cust_name,cust_contact
FROM customers
WHERE cust_id IN (SELECT cust_id
                  FROM orders
                  WHERE order_num IN (SELECT order_num
                                      FROM orderitems
                                      WHERE prod_id = 'TNT2'));
#等价于
SELECT order_num FROM orderitems WHERE prod_id = 'TNT2'; #返回20005和20007
SELECT cust_id FROM orders WHERE order_num IN (20005,20007); #返回10001和10004
SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (10001,10004);

#可用联结代替子查询
SELECT cust_name, cust_contact
FROM customers, orders, orderitems
WHERE customers.cust_id = orders.cust_id
  AND orders.order_num = orderitems.order_num
  AND orderitems.prod_id = 'TNT2';

#输出
+----------------+--------------+
| cust_name      | cust_contact |
+----------------+--------------+
| Coyote Inc.    | Y Lee        |
| Yosemite Place | Y Sam        |
+----------------+--------------+
```

**作为计算字段使用子查询**
```sql
#显示customers表中每个客户的订单总数
SELECT cust_name,
       cust_state,
       (SELECT COUNT(*)
        FROM orders
        WHERE orders.cust_id = customers.cust_id) AS orders #使用了完全限定列名
FROM customers
ORDER BY cust_name;
#输出
+----------------+------------+--------+
| cust_name      | cust_state | orders |
+----------------+------------+--------+
| Coyote Inc.    | MI         |      2 |
| E Fudd         | IL         |      1 |
| Mouse House    | OH         |      0 |
| Wascals        | IN         |      1 |
| Yosemite Place | AZ         |      1 |
+----------------+------------+--------+
```

**相关子查询** 设计外部查询的子查询。列名可能有多义性时需要使用完全限定列名(表名和列名由一个句点分隔)

```sql
#没有使用完全限定列名的错误例子
SELECT cust_name,
       cust_state,
       (SELECT COUNT(*)
        FROM orders
        WHERE cust_id = cust_id) AS orders
FROM customers
ORDER BY cust_name;
#输出
#相当于返回orders表中的订单总数(cust_id = cust_id总是正确)
+----------------+------------+--------+
| cust_name      | cust_state | orders |
+----------------+------------+--------+
| Coyote Inc.    | MI         |      5 |
| E Fudd         | IL         |      5 |
| Mouse House    | OH         |      5 |
| Wascals        | IN         |      5 |
| Yosemite Place | AZ         |      5 |
+----------------+------------+--------+
```

## 15. 联结表
**联结**(join) 用于把两个或多个表的行结合起来
- 内部联结(等值联结)
- 自联结
- 自然联结
- 外部联结

**外键** 外键为某个表中的一列，包含另一个表的[主键](#1-数据库基础)值，定义了两个表之间的关系。

**可伸缩性**(scale) 能够适应不断增加的工作量而不失败。

**创建联结** 使用WHERE子句简历联结关系
若没有WHERE子句，第一个表中的每个行将与第二个表中的每个行配对
```sql
SELECT vend_name, prod_name, prod_price
FROM vendors, products  #vend_name在vendors中，prod_name和prod_price在products表中
WHERE vendors.vend_id = products.vend_id
ORDER BY vend_name, prod_name;
#输出
+-------------+----------------+------------+
| vend_name   | prod_name      | prod_price |
+-------------+----------------+------------+
| ACME        | Bird seed      |      10.00 |
| ACME        | Carrots        |       2.50 |
| ACME        | Detonator      |      13.00 |
| ACME        | Safe           |      50.00 |
| ACME        | Sling          |       4.49 |
| ACME        | TNT (1 stick)  |       2.50 |
| ACME        | TNT (5 sticks) |      10.00 |
| Anvils R Us | .5 ton anvil   |       5.99 |
| Anvils R Us | 1 ton anvil    |       9.99 |
| Anvils R Us | 2 ton anvil    |      14.99 |
| Jet Set     | JetPack 1000   |      35.00 |
| Jet Set     | JetPack 2000   |      55.00 |
| LT Supplies | Fuses          |       3.42 |
| LT Supplies | Oil can        |       8.99 |
+-------------+----------------+------------+
```

**笛卡尔积**(cartesian product) 由没有联结条件的表关系返回的结果。检索出的行的树木将是第一个表中的行数乘以第二个表中的行数。
```sql
SELECT vend_name, prod_name, prod_price 
FROM vendors, products 
ORDER BY vend_name, prod_name;
#将输出84行。(6行vendor * 14行product)
```

**内部联结** 给予两个表之间的相等测试。也称**等值联结**(equijoin)
```sql
#另一种联结方法
SELECT vend_name, prod_name, prod_price
FROM vendors INNER JOIN products
ON vendors.vend_id = products.vend_id;
#与用WHERE子句输出的结果一样
```

**联结多个表**
```sql
#从三个表中检索出编号为20005的订单中物品的信息
SELECT prod_name, vend_name, prod_price, quantity
FROM orderitems, products, vendors
WHERE products.vend_id = vendors.vend_id
  AND orderitems.prod_id = products.prod_id
  AND order_num = 20005;
#输出
+----------------+-------------+------------+----------+
| prod_name      | vend_name   | prod_price | quantity |
+----------------+-------------+------------+----------+
| .5 ton anvil   | Anvils R Us |       5.99 |       10 |
| 1 ton anvil    | Anvils R Us |       9.99 |        3 |
| TNT (5 sticks) | ACME        |      10.00 |        5 |
| Bird seed      | ACME        |      10.00 |        1 |
+----------------+-------------+------------+----------+
```

## 16. 创建高级联结

**表别名** 别名除了用于列名和计算字段外，SQL还允许给表名起别名。
- 缩短SQL语句
- 允许在单条SELECT语句中多次使用相同的表

```sql
SELECT cust_name, cust_contact
FROM customers AS c, orders AS o, orderitems AS oi
WHERE c.cust_id = o.cust_id
  AND oi.order_num = o.order_num
  AND prod_id = 'TNT2';
```
表别名只在查询执行中使用，表别名不返回到客户机。

**自联结**(self-join) 在单条SELECT语句中多次使用相同的表。
```sql
SELECT p1.prod_id, p1.prod_name
FROM products AS p1, products AS p2
WHERE p1.vend_id = p2.vend_id
  AND p2.prod_id = 'DTNTR';
#相当于
SELECT prod_id, prod_name
FROM products
WHERE vend_id = (SELECT vend_id
                 FROM products
                 WHERE prod_id = 'DTNTR');
```
WHERE首先通过匹配p1中的vend_id和p2中的vend_id来联结两个表，然后按第二个表中的prod_id过滤数据，返回所需的数据。

**自然联结**(natural join) 排除不止出现在一个表中的列的多次出现，使每个列只返回一次。（事实上由我们自己来完成，如SELECT中的表列使用完全限定列名）
```sql
SELECT c.*, o.order_num, o.order_date,
       oi.prod_id, oi.quantity, oi.item_price
FROM customers AS c, orders AS o, orderitems AS oi
WHERE c.cust_id = o.cust_id
  AND oi.order_num = o.order_num
  AND prod_id = 'FB';
```

**外部联结** 使用OUTER JOIN语法，联结包含了那些在相关表中没有关联的行。
在使用OUTER JOIN语法时，必须使用RIGHT或LEFT关键字制定包括其所有行的表。
- RIGHT指出的是OUTER JOIN右边的表
- LEFT指出的是OUTER JOIN左边的表

```sql
#指出左边的表
SELECT customers.cust_id, orders.order_num
FROM customers LEFT OUTER JOIN orders
 ON customers.cust_id = orders.cust_id;
#输出
+---------+-----------+
| cust_id | order_num |
+---------+-----------+
|   10001 |     20005 |
|   10001 |     20009 |
|   10002 |      NULL |
|   10003 |     20006 |
|   10004 |     20007 |
|   10005 |     20008 |
+---------+-----------+

#指出右边的表
SELECT customers.cust_id, orders.order_num
FROM customers RIGHT OUTER JOIN orders
 ON customers.cust_id = orders.cust_id;
#输出
+---------+-----------+
| cust_id | order_num |
+---------+-----------+
|   10001 |     20005 |
|   10001 |     20009 |
|   10003 |     20006 |
|   10004 |     20007 |
|   10005 |     20008 |
+---------+-----------+
```

**使用带聚集函数的联结** 可用将聚集函数与联结一起使用。
```sql
SELECT customers.cust_name,
       customers.cust_id,
       COUNT(orders.order_num) AS num_ord
FROM customers INNER JOIN orders
 ON customers.cust_id = orders.cust_id
GROUP BY customers.cust_id;
#输出
+----------------+---------+
| cust_name      | cust_id |
+----------------+---------+
| Coyote Inc.    |   10001 |
| Wascals        |   10003 |
| Yosemite Place |   10004 |
| E Fudd         |   10005 |
+----------------+---------+
```

**使用联结的要点**
- 注意多使用的联结类型
- 保证使用正确的联结条件
- 应提供联结条件，防止笛卡尔积
- 一个联结中可以包含多个表。甚至每个联结可以采用不同的联结类型，但应该提前分别测试每个联结。


## 17. 组合查询
利用UNION操作符将多条SELECT语句组合成一个结果集。

**并**(union)**/复合查询**(compound query) 执行多个查询，并将结果作为耽搁查询结果集返回。
使用组合查询的基本情况：
- 在耽搁查询种从不同的表返回类似结构的数据；
- 对单个表执行多个查询，按单个查询返回数据。

**UNION操作符** 组合数条SQL查询。
```sql
SELECT vend_id, prod_id, prod_price
FROM products
WHERE prod_price <= 5
UNION
SELECT vend_id, prod_id, prod_price
FROM products
WHERE vend_id IN (1001,1002);
#输出
+---------+---------+------------+
| vend_id | prod_id | prod_price |
+---------+---------+------------+
|    1003 | FC      |       2.50 |
|    1002 | FU1     |       3.42 |
|    1003 | SLING   |       4.49 |
|    1003 | TNT1    |       2.50 |
|    1001 | ANV01   |       5.99 |
|    1001 | ANV02   |       9.99 |
|    1001 | ANV03   |      14.99 |
|    1002 | OL1     |       8.99 |
+---------+---------+------------+
```
如果两个 select 查询的是同一张表的内容，并且判断的是同一个字段，那么 union 和 or 可以相互转换

**UNION规则**
- UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔；
- UNION中的每个查询必须包含相同的列、表达式或聚集函数(次序可以不同)；
- 列数据类型必须兼容--类型不必完全相同，但必须是DBMS可以隐含地转换的类型。

**UNION ALL** 返回所有匹配行，而不是自动取消重复的行。
```sql
SELECT vend_id, prod_id, prod_price
FROM products
WHERE prod_price <= 5
UNION ALL
SELECT vend_id, prod_id, prod_price
FROM products
WHERE vend_id IN (1001,1002);
#输出
+---------+---------+------------+
| vend_id | prod_id | prod_price |
+---------+---------+------------+
|    1003 | FC      |       2.50 |
|    1002 | FU1     |       3.42 |
|    1003 | SLING   |       4.49 |
|    1003 | TNT1    |       2.50 |
|    1001 | ANV01   |       5.99 |
|    1001 | ANV02   |       9.99 |
|    1001 | ANV03   |      14.99 |
|    1002 | FU1     |       3.42 |
|    1002 | OL1     |       8.99 |
+---------+---------+------------+
#比之前多了一行,有一行出现了两次
```

**对组合查询结果排序** 在用UNION组合查询时，只能使用一条ORDER BY子句，且必须出现在最后一条SELECT语句之后，将会排序所有SELECT语句返回的所有结果。


## 18. 全文本搜索
MyISAM引擎支持全文本搜索，InnoDB引擎不支持。
**优点**
- 性能
- 明确控制
- 智能化的结果

**启用全文本搜索支持** 一般在创建表时启用全文本搜索。在CREATE TABLE语句中使用FULLTEXT子句。
```sql
#在CREATE TABLE语句中
FULLTEXT(note_text)
```
创建的表列中有一个名为note_text的列，MySQL将对它进行索引。在定义之后，MySQL自动维护该索引。

**不要在导入数据时制定FULLTEXT** 应该先导入所有数据，然后再修改表，定义FULLTEXT，有助于更快地导入数据。

**进行全文本搜索** 使用Match()制定被搜索的列，Against()制定要使用的搜索表达式。
- 传递给Match()的值必须与FULLTEXT()定义中的相同；
- 搜索不区分大小写；(除非使用BINARY方式)
- 返回的数据以文本匹配的良好程度排序。
```sql
SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('rabbit');
#输出
+----------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                            |
+----------------------------------------------------------------------------------------------------------------------+
| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                         |
| Quantity varies, sold by the sack load. All guaranteed to be bright and orange, and suitable for use as rabbit bait. |
+----------------------------------------------------------------------------------------------------------------------+
```
指示针对note_text列进行搜索，指定词rabbit作为搜索文本，返回包含了rabbit的两行。

**使用查询扩展**
1. 进行一个基本的全文本搜索，找出与搜索条件匹配的所有行；
2. MySQL检查这些匹配行并选择所有有用的词；
3. MySQL再次进行全文本搜索，不仅使用原来的条件，还使用所有有用的行。
```sql
SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('anvils' WITH QUERY EXPANSION);
#输出
+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                                                                |
+----------------------------------------------------------------------------------------------------------------------------------------------------------+
| Multiple customer returns, anvils failing to drop fast enough or falling backwards on purchaser. Recommend that customer considers using heavier anvils. |
| Customer complaint: Sticks not individually wrapped, too easy to mistakenly detonate all at once. Recommend individual wrapping.                         |
| Customer complaint: Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead.  |
| Please note that no returns will be accepted if safe opened using explosives.                                                                            |
| Customer complaint: rabbit has been able to detect trap, food apparently less effective now.                                                             |
| Customer complaint: Circular hole in safe floor can apparently be easily cut with handsaw.                                                               |
| Matches not included, recommend purchase of matches or detonator (item DTNTR).                                                                           |
+----------------------------------------------------------------------------------------------------------------------------------------------------------+
```

**布尔文本搜索** 以布尔方式(boolean mode)进行全文本搜索。
可以提供：
- 要匹配的词；
- 要排斥的词；
- 排列提示
- 表达式分组
- 另外一些内容

```sql
#匹配词heavy但排除包含rope*
SELECT note_text
FROM productnotes
WHERE Match(note_text) Against('heavy -rope*' IN BOOLEAN MODE);
#输出
+---------------------------------------------------------------------------------------------------------------------------------------------------------+
| note_text                                                                                                                                               |
+---------------------------------------------------------------------------------------------------------------------------------------------------------+
| Customer complaint: Not heavy enough to generate flying stars around head of victim. If being purchased for dropping, recommend ANV02 or ANV03 instead. |
+---------------------------------------------------------------------------------------------------------------------------------------------------------+
```

**全文本布尔操作符**

| 布尔操作符 | 说明                                                                       |
| ---------- | -------------------------------------------------------------------------- |
| +          | 包含，词必须存在                                                           |
| -          | 排除，词必须不出现                                                         |
| >          | 包含，而且增加等级值                                                       |
| <          | 包含，且减少等级值                                                         |
| ()         | 把词组成子表达式（允许这些子表达式作为一个组被包含、排除、排列等）         |
| ~          | 取消一个词的排序值                                                         |
| *          | 词尾的通配符                                                               |
| ""         | 定义一个短语《与单个词的列表不一样，它匹配整个短语以便包含或排除这个短语） |

**全文本搜索的使用说明**
- 短词(具有3个或3个以下字符的词)会被忽略且从索引中排除；
- MySQL内建的非用词(stopword)列表中的词会被忽略；
- 50%规则：如果一个词出现在50%以上的行中，会被作为非用词忽略；(此规则不用于IN BOOLEAN MODE)
- 如果表中的行数少于3行，则不返回结果；
- 忽略词中的单引号；(dont't索引为dont)
- 不具有词分隔符的语言不能恰当地返回全文本搜索结果；
- 仅在MyISAM数据库引擎中支持全文本搜索。


## 19. 插入数据
### 插入完整的行
使用INSERT语法，指定表名和被插入到新行中的值。
```sql
#依赖次序插入(不安全)
INSERT INTO customers
VALUE(NULL,
      'Pep E. LaPew',
      '100 Main Street',
      'Los Angeles',
      'CA',
      '90046',
      'USA',
      NULL,
      NULL);
#INSERT语句一般不会产生输出
```
数据在VALUES子句中按次序给出，对每个列必须提供一个值，如果某个列没有值，应该使用NULL值。
```sql
#安全的方法
INSERT INTO customers(cust_name,
                      cust_address,
                      cust_city,
                      cust_state,
                      cust_zip,
                      cust_country,
                      cust_contact,
                      cust_email)
VALUES('Pep E. LaPew',
       '100 Main Stress',
       'Los Angeles',
       'CA',
       '90046',
       'USA',
       NULL,
       NULL);
```
不管使用哪种INSERT语法，都必须给出VALUES的正确数目。
- 如果不提供列名，则必须给出每个表列提供一个值；
- 如果提供表名，则必须对每个列出的列给出一个值。

对于省略的列，需要满足：
- 该列定义为允许NULL值；
- 在表定义中给出默认值。

### 插入多个行
可以使用多条INSERT语句，一次提交它们，每条语句用一个分号结束。

若每条INSERT语句中的列名和次序相同，可以一次性在VALUE子句中提供多组值，每组值用一对圆括号括起来：
```sql
INSERT INTO customers(cust_name,
                      cust_address,
                      cust_city,
                      cust_state,
                      cust_zip,
                      cust_country)
VALUES(
        'Pep E. LaPew',
        '100 Main Stress',
        'Los Angeles',
        'CA',
        '90046',
        'USA'
      ),
      (
        'M. Martian',
        '42 Galaxy Way',
        'New York',
        'NY',
        '11213',
        'USA'
      );
```

### 插入检索出的数据
```sql
#把一个名为custnew的表中的数据导入到customers表中
INSERT INTO customers(cust_id,
                      cust_name,
                      cust_address,
                      cust_city,
                      cust_state,
                      cust_zip,
                      cust_country,
                      cust_contact,
                      cust_email)
                SELECT cust_id,
                      cust_name,
                      cust_address,
                      cust_city,
                      cust_state,
                      cust_zip,
                      cust_country,
                      cust_contact,
                      cust_email
                FROM custnew;
```
INSERT SELECT中的列名不重要，只会按对应的顺序填充新插入的行。


## 20. 更新和删除数据
### UPDATE关键字
使用UPDATE关键字进行更新（修改）表中的数据。
- 更新表中特定行；
- 更新表中所有行。

UPDATE语句的**组成**
- 要更新的表；
- 列名和它们的新值；
- 确定要更新行的过滤条件。

```sql
UPDATE customers
SET cust_email = 'elmer@fudd.com'
WHERE cust_id = 10005;
```

**更新多个列** 只需使用单个SET命令，每个“列=值”对之间用逗号分隔。
```sql
UPDATE customers
SET cust_name = 'THE Fudds',
    cust_email = "elmer@fudd.com"
WHERE cust_id = 10005;
```

**在UPDATE语句中使用子查询** 可以用SELECT语句检索出来的数据更新列数据。

**IGNORE关键字** UPDATE语句更新多行时，在更新一行或多行时出现一个错误会导致整个UPDATE操作被取消。
使用IGNORE关键字可以在发生错误时也继续进行更新。
```sql
UPDATE IGNORE customers
...
```

删除某个列的值，可将其**置为NULL**
```sql
UPDATE customers
SET cust_email = NULL
WHERE cust_id = 10005;
```

### DELETE关键字
使用DELETE语句从一个表中删除（去掉）数据。
- 从表中删除特定的行；
- 从表中删除所有的行。

```sql
#从表中删除一行
DELETE FROM customers
WHERE cust_id = 10006;`
```
DELETE删除正行而不是删除列。若要删除指定的列，应使用UPDATE语句。

**删除所有的行** 用**TRUNCATE TABLE**语句删除原来的表并重新创建一个表，而不是逐行删除表中的数据，可以更快地删除所有的行。

### 更新和删除的指导原则
- 除非确实打算更新和删除每一行，否则绝对不要使用不带WHERE子句的UPDATE或DELETE语句；
- 保证每个表都有主键，可以用WHERE子句来指定它；
- 在对UPDATE或DELETE语句使用WHERE子句前，应该先用SELECT进行测试；
- 使用强制实施引用完整性的数据库，这样MySQL将不允许删除具有与其他表相关联的数据的行；
- MySQL没有撤销按钮，应小心使用UPDATE和DELETE。


## 21. 创建和操纵表
### 创建表
使用**CREATE TABLE**语句
- 在CREATE TABLE之后给出新表的名字；
- 给出表列的名字和定义，用逗号分隔。

```sql
CREATE TABLE customers
(
  cust_id       int       NOT NULL AUTO_INCREMENT,
  cust_name     char(50)  NOT NULL ,  #cust_id, cust_name是必须的，不能被设置为NULL
  cust_address  char(50)  NULL ,      #允许NULL值
  cust_city     char(50)  NULL ,
  cust_state    char(50)  NULL ,
  cust_zip      char(50)  NULL ,
  cust_country  char(50)  NULL ,
  cust_contact  char(50)  NULL ,
  cust_email    char(50)  NULL ,
  PRIMARY KEY (cust_id)   #指定表的主键
) ENGINE=InnoDB;
```
创建新表时，指定的表名必须不存在。

**多个列组成主键** 若多个列的组合是唯一的，且都为NOT NULL列，可以组成主键
```sql
PRIMARY KEY (order_num, pder_item)
```

**AUTO_INCREMENT** 告诉MySQL，每当本列增加一行时自动增量，给每一行分配一个唯一的值。
每个表只允许一个AUTO_INCREMENT的列，并且它必须被索引。

**last_insert_id()函数** 返回最后一个AUTO_INCREMENT值，可以用于后续的语句中。

**指定默认值** 使用DEFAULT关键字指定某行插入时的默认值。
```sql
CREATE TABLE orderitems
(
  ...
  quantity int  NOT NULL  DEFAULT 1,
  ...
  PRIMARY KEY (order_num,order_item)
) ENGINE=InnoDB;
```
MySQL不允许使用函数作为默认值，只支持常量。

**引擎类型**
- InnoDB 可靠的事务处理引擎；
- MyISAM 性能极高的引擎，支持全文本搜索，但不支持事务处理；
- MEMORY 功能等同于MyISAM，但数据存储在内存，速度很快，适合于临时表。

引擎类型可以混用，但外键不能跨引擎。

### 更新表
使用**ALTER TABLE语句**更新表定义。（常见用途：定义外键）
- 在ALTER TABLE之后要更改的表名（该表必须存在）；
- 给出所作更改的列表。

```sql
#给表添加一个列
ALTER TABLE vendors
ADD vend_phone CHAR(20);
```
```sql
#删除刚刚添加的列
ALTER TABLE vendors
DROP COLUMN vend_phone;
```

### 删除表
使用**DROP TABLE**语句
```sql
DROP TABLE customer2;
```

### 重命名表
使用**RENAME TABLE**语句重命名一个表。
```sql
RENAME TABLE customers2 TO customers,
             backup_customers TO customer,
             backup_vendors TO vendors,
             back_ip_products TO products;
```
本章的语句必须小心使用，应在做了备份后使用。

## 22. 使用视图

### 视图
**视图**是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询。
优点：
- 重用SQL语句；
- 简化复杂的SQL操作；
- 使用表的组成部分而不是整个表；
- 保护数据；
- 更改数据格式和表示。

规则和限制：
- 命名必须唯一；
- 对于可以创建的视图数目没有限制；
- 为了创建视图，必须具有足够的访问权限；
- 视图可以嵌套；
- ORDER BY可以用在视图中；
- 视图不能索引，也不能有关联的触发器或默认值；
- 视图可以和表一起使用。

**创建** 使用**CREATE VIEW**语句。

**查看创建视图的语句** 使用
```SQL
SHOW CREATE VIEW viewname;
```
**删除视图** 使用
```sql
DROP VIEW viewname;
```
**更新视图** 可以先**DROP**再**CREATE**，或者用**CREATE OR REPLACE VIEW**。

创建视图：
```SQL
CREATE VIEW productcustomers AS
SELECT cust_name, cust_contact, prod_id
FROM customers, orders, orderitems
WHERE customers.cust_id = orders.cust_id
  AND orderitems.order_num = orders.order_num;
```

检索视图：
```sql
SELECT cust_name, cust_contact
FROM productcustomers
WHERE prod_id = 'TNT2';
```
输出：
```
+----------------+--------------+
| cust_name      | cust_contact |
+----------------+--------------+
| Coyote Inc.    | Y Lee        |
| Yosemite Place | Y Sam        |
+----------------+--------------+
```

### 使用视图重新格式化检索出的数据
创建视图：
```sql
CREATE VIEW vendorlocations AS
SELECT Concat(RTrim(vend_name), ' (', RTrim(vend_country), ')')
       AS vend_title
FROM vendors
ORDER BY vend_name;
```
检索数据：
```sql
SELECT *
FROM vendorlocations;
```
输出：
```
+-------------------------+
| vend_title              |
+-------------------------+
| ACME (USA)              |
| Anvils R Us (USA)       |
| Furball Inc. (USA)      |
| Jet Set (England)       |
| Jouets Et Ours (France) |
| LT Supplies (USA)       |
+-------------------------+
```

视图的其他用法：
- **用视图过滤不想要的数据**；
- **用视图简化计算字段**。

### 更新视图
通常视图是可更新的。（使用INSERT、UPDATE和DELETE）
当视图定义中有一下操作，则不能更新：
- 分组（使用GROUP BY和HAVING）；
- 联结；
- 子查询；
- 并；
- 聚集函数（MIN()、COUNT()、Sum()等）；
- DISTINCT；
- 导出（计算）列。


## 23. 使用存储过程
**存储过程** 简单来说就是为以后的使用而保存的一条或多条MySQL语句的集合。
优点：
- 简单
- 安全
- 高性能

缺点：
- 编写复杂，需要更高的能力；
- 可能没有创建存储过程的安全访问权限。


### 创建存储过程
使用**CREATE PROCEDURE**语句。

create名为productpricing的存储过程。
```sql
CREATE PROCEDURE productpricing()
BEGIN
  SELECT Avg(prod_price) AS priceaverage
  FROM products;
END;
```

**若使用mysql命令行实用程序**
默认的MySQL语句分隔符为"**;**"，mysql命令行实用程序也使用"**;**"作为分隔符，这会导致句法错误。

解决办法：
```sql
DELIMITER //    #告诉命令行实用程序使用"//"作为新的分隔符

CREATE PROCEDURE productpricing()
BEGIN
  SELECT Avg(prod_price) AS priceaverage
  FROM products;
END //          #此处使用了"//"作为分隔符

DELIMITER ;     #将分隔符改回";"
```


### 执行存储过程
**调用** 存储过程的执行，使用CALL关键字。
```sql
CALL productpricing();
```
输出
```shell
+--------------+
| priceaverage |
+--------------+
|    16.133571 |
+--------------+
```

CALL接受存储过程的名字以及需要传递给它的任意参数，如：
```sql
CALL productpricing(@pricelow,
                    @pricehigh,
                    @priceaverage);
```

### 删除存储过程
使用**DROP PROCEDURE**语句
```sql
DROP PROCEDURE productpricing;
```

### 使用参数
一般来说，存储过程并不显示结果，而是把结果返回给你指定的变量。

**变量**(variable) 内存中一个特定的位置，用来临时存储数据。
**变量名** 所有MySQL变量都必须以@开始。

```sql
DELIMITER //

CREATE PROCEDURE productpricing(
  OUT p1 DECIMAL(8,2),
  OUT ph DECIMAL(8,2),
  OUT pa DECIMAL(8,2)
)
BEGIN
  SELECT Min(prod_price)
  INTO p1
  FROM products;
  SELECT Max(prod_price)
  INTO ph
  FROM products;
  SELECT Avg(prod_price)
  INTO pa
  FROM products;
END //

DELIMITER ;
```

关键字
- **OUT** 指出相应的参数用来从存储过程传出一个值，返回给调用者；
- **IN** 传递给存储过程；
- **INOUT** 对存储过程穿入和传出。

调用新的productpricing：
```sql
CALL productpricing(@pricelow,
                    @pricehigh,
                    @priceaverage);
```
显示检索出的值：
```sql
SELECT @pricehigh, @pricelow, @priceaverage;
```
输出：
```shell
+------------+-----------+---------------+
| @pricehigh | @pricelow | @priceaverage |
+------------+-----------+---------------+
|      55.00 |      2.50 |         16.13 |
+------------+-----------+---------------+
```

**使用IN参数**
```sql
DELIMITER //

CREATE PROCEDURE ordertotal(
  IN onumber INT,
  OUT ototal DECIMAL(8,2)
)
BEGIN
  SELECT Sum(item_price*quantity)
  FROM orderitems
  WHERE order_num = onumber
  INTO ototal;
end //

DELIMITER ;
```
使用ordertotal：
```sql
CALL ordertotal(20005, @total);
SELECT @total;
```
输出：
```shell
+--------+
| @total |
+--------+
| 149.87 |
+--------+
```

### 检查存储过程
显示用来创建存储过程的CREATE语句：
```sql
SHOW CREATE PROCEDURE ordertotal;
```

列出存储过程：
```sql
SHOW PROCEDURE STATUS;

SHOW PROCEDURE STATUS LIKE 'ordertotal';
```

## 24. 使用游标
**游标**(cursor) 一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。MySQL游标只能用于存储过程和函数。

**使用游标**
- 声明游标；
- 一旦声明后，必须打开游标以供使用；
- 对于填有数据的游标，根据需要取出各行；
- 在结束游标使用时，必须关闭游标。

**创建游标** 使用DECLARE语句创建，命名游标并定义相应的SELECT语句。
```sql
DROP PROCEDURE IF EXISTS processorders;

DELIMITER //

CREATE PROCEDURE processorders()
BEGIN
  DECLARE done BOOLEAN DEFAULT 0;
  DECLARE o INT;

  DECLARE ordernumbers CURSOR
  FOR
  SELECT order_num FROM orders;
  DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done=1;
  OPEN ordernumbers;
  REPEAT
    FETCH ordernumbers INTO o;
    SELECT o;
  UNTIL done END REPEAT;
  CLOSE ordernumbers;
END //

DELIMITER ;
```

## 25. 使用触发器
目的：想要某条或某些语句在事件发生时自动执行。

**触发器** 在MySQL响应以下任意语句而自动执行的一条MySQL语句
- DELETE；
- INSERT；
- UPDATE。

### 创建触发器
使用**CREATE TRIGGER**语句。
需要给出：
- 唯一的触发器名；
- 触发器关联的表；
- 触发器应该相应的活动（DELETE、INSERT或UPDATE）；
- 触发器何时执行

```SQL
--创建名为newproduct的新触发器
--触发器在INSERT语句成功执行后执行
CREATE TRIGGER newproduct AFTER INSERT ON products
FOR EACH ROW SELECT 'Product added';
--代码对每个插入行执行
```
从MySQL5以后不支持触发器返回结果集，要使用INTO：
```sql
CREATE TRIGGER newproduct AFTER INSERT ON products
FOR EACH ROW SELECT 'Product added' INTO @message;
```

### 删除触发器
使用**DROP TRIGGER**语句。
```sql
DROP TRIGGER newproduct;
```

### 使用触发器
**INSERT触发器** 在INSERT语句执行之前或之后执行。
- 在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；
- 在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的行）；
- 对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。

**DELETE触发器** 在DELETE语句执行之前或之后执行。
- 在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，访问被删除的行；
- OLD中的值全都是只读的，不能更改。

**UPDATE触发器**
- 在UPDATE触发器代码中，可以引用一个名为OLD的虚拟表访问以前的值；
- 可以引用一个名为NEW的虚拟表访问新更新的值；
- 在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；
- OLD中的值全都是只读的，不能更新。

## 26. 管理事务处理
**事务处理**(transaction processing) 一种机制，用来管理成批执行的MySQL操作，以保证数据库不包含不完整的操作结果。

术语：
- **事务**(transaction) 指一组SQL语句；
- **回退**(rollback) 指撤销指定SQL语句的过程；
- **提交**(commit) 指将未存储的SQL语句结果写入数据库表；
- **保留点**(savepoint) 指事务处理中设置的临时占位符，可以对它发布回退。

### 控制事务处理
**ROLLBACK命令** 用来回退MySQL语句。
```sql
SELECT * FROM ordertotals;
START TRANSACTION;    #标识事务的开始
DELETE FROM ordertotals;  #把表清空
SELECT * FROM ordertotals;
ROLLBACK;   #回退
SELECT * FROM ordertotals;
``` 
- 事务处理用来管理INSERT、UPDATE、和DELETE语句；
- 不能回退CREATE或DROP操作。

**隐含提交**(implicit commit) 一般的MySQL语句都是直接针对数据库表执行和编写的，即提交操作是自动进行的。但在事务处理块中，提交不会隐含地进行。
**使用COMMIT语句** 在事务处理块中，进行明确的提交

```sql
START TRANSACTION;
DELETE FROM orderitems WHERE order_num = 20010;
DELETE FROM orders WHERE order_num = 20010;
COMMIT;   #若第一条DELETE起作用，第二条失败，则第一条DELETE会自动撤销
```
执行COMMIT和ROLLBACK之后事务会自动关闭。

**使用保留点**
创建占位符：
```sql
SAVEPOINT delete1;
```
回退到保留点：
```sql
ROLLBACK TO delete1;
```
释放保留点：
- 事务处理完成后自动释放；
- 用**RELEASE SAVEPOINT**明确地释放保留点。

**autocommit标志** 决定是否自动提交更改。（针对连接专用）
```sql
SET autocommit = 0;   #指示MySQL不自动提交更改，知道autocommit被设置为真
```

## 27. 全球化和本地化
**字符集** 字母和符号的集合；
**编码** 某个字符集成员的内部表示；
**校对** 规定字符如何比较的指令。

**查看MySQL所支持的字符集完整列表**：
```sql
SHOW CHARACTER SET;
```
显示所有可用的字符集以及每个字符集的描述和默认校对。

**查看所支持校对的完整列表**：
```sql
SHOW COLLATION;
```
显示所有可用的校对，以及它们适用的字符集。

**确定所用的字符集和校对**
```sql
SHOW VARIABLES LIKE 'character%';
SHOW VARIABLES LIKE 'collation%';
```

**给表指定字符集和校对** 使用带子句的CREATE TABLE：
```sql
#创建一个包含两列的表，并指定一个字符集和一个校对顺序
CREATE TABLE mytable
(
    columnn1  INT,
    columnn2  VARCHAR(10),
    column3   VARCHAR(10) CHARACTER SET latin1
              COLLATE latin1_general_ci  #为特定的列指定CHARACTER和COLLATE
) DEFAULT CHARACTER SET hebrew
  COLLATE hebrew_general_ci;    #指定CHARACTER和COLLATE
```

**用与创建表时不同的校对顺序排序指定的SELECT语句**：
```sql
SELECT * FROM customers
ORDER BY lastname, firstname COLLATE latin1_general_CS;
```
COLLATE还可以用于GROUP BY、 HAVING、聚集函数、别名等。

## 28. 安全管理
### 访问控制
- 防止用户的恶意企图；
- 保证用户不能执行不应该执行的语句（如错打MySQL语句、在不合适的数据库中操作或其他用户错误）。

### 管理用户
**获得所用用户账号列表**
```sql
USE mysql;
SELECT user from user;
```

**创建新用户账号** 使用CREATE USER语句
```sql
CREATE USER ben IDENTIFIED BY '123456';
```

**重命名账号** 使用RENAME USER语句
```sql
RENAME USER ben TO bforta;
```

**删除用户账号** 使用DROP USER语句
```sql
DROP USER bforta;
```

**显示赋予账号的权限** 使用SHOW GTRANTS FOR
```sql
SHOW GRANTS FOR bforta;
```

**设置权限** 使用GRANT语句，要求给出：
- 要授予的权限；
- 被授予访问权限的数据库或表；
- 用户名
```sql
#允许用户bforta在crashcourse数据库的所有表上使用SELECT
GRANT SELECT ON crashcourse.* TO bforta;
```

**撤销特定的权限** 使用REVOKE
```sql
REVOKE SELECT ON crashcourse.* FROM bforta;
```
![](/assets/images/2022-04-04-20-46-02.png)

**更改口令** 使用SET PASSWORD语句
```sql
SET PASSWORD FOR bforta = Password('123456');
```

MySQL 8之后使用以下语句：
```sql
ALTER user bforta IDENTIFIED BY 'newpassward';
flush privileges;
```

## 29. 数据库维护
**备份数据**
- 使用命令行mysqldump转储所有数据库内容到某个外部文件；
- 使用命令行mysqlhotcopy从一个数据库复制所有数据；
- 使用MySQL的BACKUP TABLE或SELECT INTO OUTFILE转储所有数据到某个外部文件。复原数据用RESTORE TABLE。

**数据库维护**
- **ANALYZE TABLE** 检查表键是否正确：
```sql
ANALYZE TABLE orders;
```
输出：

```
+--------------------+---------+----------+----------+
| Table              | Op      | Msg_type | Msg_text |
+--------------------+---------+----------+----------+
| crashcourse.orders | analyze | status   | OK       |
+--------------------+---------+----------+----------+
```

- **CHECK TABLE** 针对许多问题对表进行检查。
```sql
CHECK TABLE orders, orderitems;
```
输出：
```
+------------------------+-------+----------+----------+
| Table                  | Op    | Msg_type | Msg_text |
+------------------------+-------+----------+----------+
| crashcourse.orders     | check | status   | OK       |
| crashcourse.orderitems | check | status   | OK       |
+------------------------+-------+----------+----------+
```

**重要的mysqld命令行选项**
在排除系统启动问题时，在命令行上执行mysqld启动MySQL服务器。
- --help 显示帮助
- --safe-mode 装载减去某些最佳配置的服务器
- --verbose显示全文本消息（与--help联合使用）
- --version显示版本信息然后退出

**日志文件**
- 错误日志 hostname.err
- 查询日志 hostname.log
- 二进制日志 hostname-bin
- 缓慢查询日志 hostname-slow.log

**FLUSH LOGS**刷新和重新开始所有的日志文件。

## 30. 改善性能
**SHOW PROCESSLIST命令** 显示所有活动进程以及它们的线程ID和执行时间。
**KILL命令** 终结某个特定的进程。