---
layout: article
title: C++ Primer 第15章 面向对象程序设计
tags: 
    - 笔记
    - C++
---
关键词：
- 基类、派生类、继承、virtual、final、override、虚函数、纯虚函数、抽象基类
<!--more-->

## 15. 面向对象程序设计

### OOP概述
**面向对象程序设计**(object-orented programming)
- 核心思想
  - 数据抽象
  - 继承
  - 动态绑定

**继承**(inheritance) 类通过继承联系在一起，构成一种层次关系。
- **基类**(base class)$$\stackrel{直接或间接继承}{\longrightarrow}$$**派生类**(derived class)
  - **基类**
    - 基类定义在层次关系中所有类共同拥有的成员
    - 基类通常都应该定义一个**虚**析构函数，即使该函数不执行任何实际操作。
    - **受保护的**(protected)成员 使用protected访问运算符说明成员是受保护的，它的派生类有权访问该成员，禁止其他用户访问。
  - **派生类**
    - 派生类定义各自特有的成员
    - 派生类通过使用**类派生列表**(class derivation list) 明确指出从哪个（哪些）基类继承而来，每个基类前面可以有public、protected、private中的一种
- **基类的成员函数**分两种：
  1. 基类希望其派生类进行**覆盖**的函数，应定义为**虚函数**；
  2. 基类希望派生类**直接继承**而不要改变的函数。
- **虚函数**(virtual function) 应在派生类中重新定义的成员函数
  - 在函数声明处使用**virtual**关键字（不能用于类外部的函数定义），使该函数执行动态绑定；
  - 该函数在派生类中隐式地也是虚函数；
  - 派生类必须在其内部对所有重新定义的虚函数进行声明；
  - 在成员函数声明或定义中，**override**关键字确保该函数为虚函数并覆写来自基类的虚函数。

```cpp
class Quote {
public:
    Quote() = default;
    Quote(const std::string &book, double sales_price) :
        bookNo(book), price(sales_price) {}
    std::string isbn() const { return bookNo; }
    virtual double net_price(std::size_t n) const
        { return n * price; }
    virtual ~Quote() = default;     //对析构函数进行动态绑定
private:
    std::string bookNo;
protected:
    double price = 0.0;
};

class Bulk_quote : public Quote {       //类派生列表，Bulk_quote继承了Quote
                                        //public关键字指明可以把bulk_quote的对象当成Quote的对象来使用
public:
    Bulk_quote() = default;
    Bulk_quote(const std::string&, double, std::size_t, double);
    double net_price(std::size_t) const override;   //覆盖基类的函数版本以实现基于大量购买的折扣政策
private:
    std::size_t min_qty = 0;    //适用折扣政策的最低购买量
    double discount = 0.0;      //以小数表示的折扣额
};
```

**动态绑定**(dynamic binding)/**运行时绑定**(run-time binding) 当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。
- 发生条件
  1. 基类中定义了虚函数 
  2. 派生类中对继承自基类的虚函数进行了覆盖（重写），
  3. 存在继承关系，
- 在这种情况下，使用父类的指针或者引用调用虚函数时，这个调用可能在运行时，绑定到不同的子类中，产生不同的行为。

---

### 定义基类和派生类
#### 基类与派生类
**派生类对象及派生类向基类的类型转换**  
- 派生类对象的组成
  - 一个含有自己定义的（非静态）成员的子对象
  - 与该派生类继承的基类对应的子对象（数量与基类的数量相同）
- 因为在派生类对象中含有与其基类对应的组成部分，所以能**把派生类的对象当成基类对象来使用**，也能**将基类的指针或引用绑定到派生类对象中的基类部分上**。
  ```cpp
  Quote item;         //基类对象
  Bulk_quote bulk;    //派生类对象
  Quote *p = &item;   //基类指针
  p = &bulk;          //基类指针指向派生类的基类部分
  Quote &r = bulk;    //基类引用绑定到派生类的基类部分
  ```
  - 这种转换称为**派生类到基类的**(derived-to-base)类型转换，可以隐式执行。
- 也可以把派生类对象的指针用在需要基类指针的地方。

**派生类构造函数** 派生类必须使用基类的构造函数来初始化它的基类部分
```cpp
//派生类的构造函数，里面调用了基类的构造函数
Bulk_quote(const std::string& book, double p, std::size_t qty, double disc) :
        Quote(book, p), min_qty(qty), discount(disc) {}
```

**派生类使用基类的成员** 派生类可以访问基类的公有成员和受保护成员。

**继承与静态成员**
- 如果基类定义了一个静态成员，不论基类中派生出来多生个派生类，在整个继承体系中只存在该成员的唯一定义；
- 静态成员遵循通用的访问控制规则（public、private、protected）;
- 若某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它

**派生类的声明** 声明中包含类名但是不包含它的派生列表
```cpp
class Bulk_quote : public Quote;    //错误
class Bulk_quote;                   //正确
```

**被用作基类的类**
- 如果想将某个类用作基类，则该类必须已经定义而非仅仅声明；
- 一个类不能派生它本身；
- 一个类是基类，同时也可以是一个派生类
  - **直接基类**(direct base) 直接出现在派生列表中
  - **间接基类**(indirect base) 由派生类通过其直接基类继承而来
```cpp
//Base为D1的直接基类
//Base为D2的间接基类
class Base {
    //...
};
class D1 : public Base {
    //...
};
class D2 :public D1 {
    //...
}
```

**防止继承的发生** 使用**final**关键字防止类被继承
```cpp
class NoDerived final {
    //...
};
class Bad : NodeDerived {   //错误，NoDerived不能被继承
    //...
};
```

#### 类型转换与继承
- 我们可以将基类的指针或引用绑定到派生类对象上
- 当使用基类的指针或引用时，我们并不清楚所绑定的对象的真实类型（基类or派生类？）
- 智能指针也支持派生类香基类的类型转换

**静态类型与动态类型**
- **静态类型**(static type)：类型在编译时已知，是变量声明时的类型或表达式生成的类型；
- **动态类型**(dynamic type)：类型在运行时才可知，时变量或表达式表示的内存中的对象类型
```cpp
//item的静态类型是Quote&，动态类型依赖于item绑定的实参
double print_total(ostream &os, const Quote &item, size_t n) {
    double ret = item.net_price(n);
    //...
}
```
- 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。
- 不存在从基类向派生类的隐式类型转换
- 当我们用一个派生类对象为一个基类对象初始化或赋值时，至于该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉

---

### 虚函数
- 我们必须为每一个虚函数**都提供定义**，而不管它是否被用到了，因为连编译器也无法确定到底会使用哪个虚函数
- 当某个虚函数**通过指针或引用调用**时，编译器产生的代码直到**运行时**才能确定应该调用哪个版本（与动态类型相匹配的那个）
- 当我们通过一个具有**普通类型**（非指针非引用）的表达式调用虚函数时，在**编译时**就会将调用的版本确定下来

> 当且仅当通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。

> **多态性**(polymorphism) 指程序能通过引用或指针的动态类型获取类型特定行为的能力。

**派生类中的虚函数**
- 当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质（也可以不使用，因为函数一旦被声明为虚函数，则在所有派生类中都是虚函数）
- 一个派生类的函数如果覆盖了某个继承而来的虚函数，则形参类型必须与被覆盖的基类函数完全一致
- 派生类中虚函数的返回类型也必须与基类函数匹配（除非虚函数返回类型时类本身的指针或引用）

**final和override说明符** 出现在形参列表以及尾置返回类型之后。
- 如果使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错；
- 如果已经把函数定义成final了，则之后任何尝试覆盖该函数的操作都将引发错误。

**回避虚函数的机制**
使用作用域运算符强迫执行虚函数的某个特定版本（通常用在成员函数或友元中）
```cpp
//强行调用基类中定义的函数版本而不管BaseP的动态类型是什么
double undiscounted = baseP->Quote::net_price(42);
```

---

### 抽象基类
**纯虚函数**(pure vietual) 在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加```=0```。
- ```=0```只能出现在类内部的虚函数声明语句处；
- 可以为纯虚函数提供定义，不过函数必须定义在类的外部。
```cpp
//一个抽象基类
class Disc_quote : public Quote
{
public:
    Disc_quote() = default;
    Disc_quote(const std::string &book, double price, std::size_t qty, double disc) :
        Quote(book, price), quantity(qty), discount(disc) {}
    double net_price(std::size_t) const = 0;    //纯虚函数
private:
    std::size_t quantity = 0;
    double discount = 0.0;
};
```

**抽象基类**(abstract base class)：含有（或者未经覆盖直接继承）纯虚函数的类。
- 抽象基类负责定义接口，而后序的其他类可以覆盖该接口；
- 不能直接创建一个抽象基类的对象；
  ```cpp
  Disc_quote discounted;  //错误
  ```
- 如果抽象基类的派生类定义覆盖纯虚函数，则仍为抽象基类。

---

### 访问控制与继承
一个类使用**protected**关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。
- 受保护的成员对于**类的用户**来说是**不可访问的**；
- 受保护的成员对于**派生类的成员和友元**来说是**可访问的**。
- 派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，对于普通的基类对象的成员不具有特殊的访问权限。

**派生列表访问说明符**
- 对于派生类的成员及友元能否访问其直接基类的成员没什么影响，只与基类中的访问说明符有关；
- 派生访问说明符的目的是控制派生类用户对于基类成员的访问权限

**派生类向基类转换的可访问性**
- 只有当D**公有地继承**B时，**用户代码才能使用**派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换；
- **不论D以什么方式继承**B，D的**成员函数和友元都能使用**派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。
- 如果D继承B的方式是**公有的或者受保护的**，则D的**派生类的成员和友元可以使用**D向B的类型转换，反之，如果D继承B的方式是私有的，则不能使用。

|    访问权限    | public | protected | private |
| :------------: | :----: | :-------: | :-----: |
|     对本类     |  可见  |   可见    |  可见   |
|     对子类     |  可见  |   可见    | 不可见  |
| 对外部(调用方) |  可见  |  不可见   | 不可见  |

> 不能继承友元关系，每个类负责控制各自成员的访问权限。

**改变个别成员的可访问性** 通过使用using声明可以改变派生类继承的某个名字的访问级别。
```cpp
class Base {
public:
    std::size_t size() { return n; }
protected:
    std::size_t n;
};
class Derived : private Base {  //private继承，size和n在Derived中本应该为private
public:
    using Base::size;   //让size保持public
protected:
    using Base::n;      //让n保持protected
}
```
> 派生类只能为那些它可以访问的名字提供using声明

**class和struct的继承**  
默认情况下
- 使用class关键字定义的派生类是私有继承的；
- 使用struct关键字定义的派生类是公有继承的；
```cpp
class Base { /*...*/ };
struct D1 : Base { /*...*/ };   //默认public继承
class D2 : Base { /*...*/ };    //默认private继承
```

---

### 继承中的类作用域
- 当存在继承关系时，派生类的作用域**嵌套**在其基类的作用域之内；
- 如果一个名字在派生类的作用域内无法正确解析，则编译器将**继续在外层的基类作用域中寻找**该名字的定义；
- 指向派生类的基类指针（动态类型与静态类型不一致）只能从基类的作用域开始搜索，**无法进入派生类的作用域范围**；
- 派生类能重用定义在其直接基类或间接基类中的名字，此时派生类的成员将**隐藏同名的基类成员**（可以使用作用域运算符::来使用被隐藏的成员）；
- 声明在内层作用域的函数并**不会重载**声明在外层作用域的函数，即使派生类成员和基类成员的形参不一样，基类成员也仍然会被隐藏掉（因此基类和派生类中的虚函数必须有相同的形参列表）。

---

### 构造函数与拷贝控制
**虚析构函数**
- 如果delete的指针的静态类型与被删除对象的动态类型的时候，编译器必须清楚应该执行的是哪一个析构函数；
- 一个基类总是需要析构函数，而且它能将析构函数设定为虚函数；
- 如果基类的析构函数不是虚函数。则delete一个指向派生类对象的基类指针将产生未定义的行为。
```cpp
class Quote {
    public:
        virtual ~Quote() = default;
};
```

**派生类中删除的函数**
- 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的；
- 如果基类中有一个不可访问或删除的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的；
- 如果基类中的移动操作或析构函数是删除的或不可访问的，则派生类的移动操作也将是被删除的。

**移动操作与继承**  
若基类缺少移动操作会组织派生类拥有自己的合成移动操作。
- 当确实需要执行移动操作时应该首先在基类中进行定义；
- 除非派生类中含数排斥移动的成员，否则它将自动获得合成的移动操作。
```cpp
class Quote {
public:
    //...
    Quote(Quote&&) = default;
    Quote& operator=(Quote&&) = default'
};
```

**派生类的拷贝控制成员**
- 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象；
- 当为派生类定义拷贝或移动构造函数时，同时常用对应的基类构造函数初始化对象的基类部分（否则基类成员将被赋予默认值）；
```cpp
    class Base { /*...*/ };
    class D : public Base {
        D(const D& d) : Base(d) /*...*/ {}
        D(D&& d) : Base(std::move(d)) /*...*/ {}
    };
```
- 派生类的赋值运算符也必须显式地为其基类部分赋值：
```cpp
D &D::operator=(const D &rhs) {
    Base::operator=(rhs);   //为基类部分赋值，该语句不会自动被调用
    //...
    return *this;
}
```
- 派生类的析构函数只负责销毁有派生类自己分配的资源
```cpp
class D : public Base {
public:
    //Base::~Base会自动调用执行
    ~D() { /*...*/ }
}
```

> 对象的构造顺序：间接基类->直接基类->派生类  
> 对象的析构顺序：派生类->直接基类->间接基类

**继承的构造函数**  
提供一条指明了直接基类名的using声明语句来让派生类继承基类构造函数：
```cpp
//令Bulk_quote类继承Disc_quote类的构造函数
class Bulk_quote : public Disc_quote {
public:
	using Disc_quote::Disc_quote;	//继承Disc_quote的构造函数
	//...
};
```
- 构造函数的using声明不会改变该构造函数的访问级别（如基类中为private，派生类中仍为private）；
- using声明语句不能指定explicit或constexpr，如果基类的构造函数时explicit或者constexpr，继承的构造函数也拥有相同的属性；
- 当基类构造函数含有默认实参时，这些实参并不会被继承，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参；
- 如果基类含有几个构造函数，大多数时候派生类会继承所有这些构造函数。有两个例外情况：
  1. 派生类自己定义的构造函数与基类的构造函数具有相同的参数列表，会替换掉基类的构造函数，只继承一部分构造函数；
  2. 默认、拷贝和移动构造函数不会被继承。

---

### 容器与继承
当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。
- 当把基类对象放入派生类的容器时，会发生错误，因为基类不能转换成派生类；
- 当把派生类对象放入基类的容器时，正确，但对象中的派生类部分会被“切掉”。

**再容器中放置（智能）指针而非对象**  
当容器中存放具有继承关系的对象时，存放的通常时基类的指针（智能指针更好），这些指针所指的动态类型可能时基类类型，也可能时派生类类型。
```cpp
vector<shared_ptr<Quote>> basket;
//存入基类
basket.push_back(make_shared<Quote>("0-201-82470-1", 50));
//存入派生类
basket.push_back(make_shared<Bulk_quote>("0-201-54848-8", 50, 10, .25));
```